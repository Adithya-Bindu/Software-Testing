                                                            SOFTWARE TESTING
                                                        ------------------------

INTRODUCTION TO SOFTWARE TESTING
--------------------------------
Software Testing is a process of verifying and validating whether the Software Product or Application is working as expected or not. The
complete testing includes identifying errors and bugs that cause future problems for the performance of an application.

Software Testing Can be Divided into Two Steps:

1. Verification: This step involves checking if the software is doing what is supposed to do. Its like asking, "Are we building the 
   product the right way?"
2. Validation: This step verifies that the software meets the customer's needs and requirements. It's like asking, "Are we building the
   right product?"


What is Manual Testing?
Manual testing is a type of testing in which we do not use any tools or automation to perform the testing. In this testing, testers make
test cases for the codes test the software, and give the final report about that software. Manual testing is time-consuming testing 
because humans do it and there is a chance of human errors.

* Manual testing is conducted to discover bugs in the developed software application.
* The tester checks all the essential features of the application.
* The tester executes test cases and generates test reports without any help from the automation tools.
* It is conducted by the experienced tester to accomplish the testing process.

When to Perform Manual Testing?
Manual testing is done when automation can't be used or isn't enough. Here are key reasons and scenarios:

* Exploratory Testing: Discovering issues in new or unclear features by exploring them.
* Usability Testing: Checking if the UI is easy to use and looks good.
* Ad-Hoc Testing: Doing quick, informal tests after updates or bug fixes.
* Visual/GUI Testing: Checking the layout, colors, or how the site looks across different browsers.

Manual testing should be conducted when:

* Flexibility is required: With manual tests, QA can quickly test and provide fast feedback.
* Short-term projects: It is not advisable to invest more money and effort to set up short-term projects that focus on minor features
  because such setup will require huge effort and money that would be too high for such small projects.
* When testing end-user usability: Humans can use their sensibilities to understand the application behavior if the application offers a 
  satisfactory user journey. No machine can perform this task as humans can.

Benefits of Manual Testing -
Here are the Benefits of Manual Testing:

* Easy hiring: In manual testing, anyone can test so it helps in easy hiring.
* Fast feedback: Manual testing helps to provide fast and accurate feedback.
* Versatile: Manual test cases can be applied to many test cases.
* Flexible: Manual testing is flexible as it can adapt easily to changes in the user interface.
* Less expensive: Manual testing is less expensive as one does not need to spend a budget on automation tools and processes.

Limitations of Manual Testing - 
Here are the Limitations of Manual Testing:

* Not all defects detected: In manual cases, there is no assurance that there will be 100% test coverage as a result some of the defects
  may not be detected.
* High expertise: Although manual testing can be done by anyone, in some complex cases high expertise is required.
* Lots of time: Manual testing times extensive activity. It requires a lot of time to manually develop test cases so that all the 
  functionalities are covered and tested.
* Cannot be recorded: Manual testing process cannot be recorded so it is not possible to reuse the manual test cases.
* Less reliable: Manual testing is less reliable as it is conducted by humans and all test cases are designed by humans so there are 
  chances for human error.


What is Automation Testing?
Automation testing is a type of testing in which we take the help of tools (automation) to perform the testing. It is faster than manual 
testing because it is done with some automation tools. There is no chance of any human errors.

* It relies entirely on pre-scripted test which runs automatically to compare actual results with expected results.
* Automation testing helps the tester determine whether the application performs as expected or not.
* It allows the execution of repetitive tasks and regression tests.
* Automation requires manual effort to create initial testing scripts.

When to Perform Automation Testing?
* When need to run repetitive tasks: Automated tests are the best option in scenarios where there is a requirement to run repetitive tests.
  For example, in the case of regression tests must be executed periodically to make sure that the newly added code does not disrupt the 
  existing functionality of the software.
* When human resources are scarce: Automated tests are viable and the best option to get tests executed within deadlines when there are 
  only a limited number of dedicated testers.

Benefits of Automation Testing -
Here are Benefits of Automation Testing:

* Finds more bugs: Automation testing helps to find more bugs and defects in the software.
* Reduce time for regression tests: Automated tests are suitable for regression tests as the tests can be executed in a repetitive manner 
  periodically.
* The process can be recorded: This is one of the benefits of using automation tests as these tests can be recorded and thus allows to 
  reuse of the tests.
* No fatigue: As automation, tests are executed using software tools so there is no fatigue or tiring factor as in manual testing.
* Increased test coverage: Automation tests help to increase the test coverage as using the tool for testing helps to make sure that not
  even the smallest unit is left for testing.

Limitations of Automation Testing - 
Here are Limitations of Automation Testing:

* Difficult to inspect visual elements: In automated tests, it is difficult to get insight into the visual elements like color, font size,
  font type, button sizes, etc. as there is no human intervention.
* High cost: Automation tests have a high cost of implementation as tools are required for testing, thus adding the cost to the project 
  budget.
* Test maintenance is costly: In automation tests, test maintenance is costly.
* Not false proof: Automation tests also have some limitations and mistakes in automated tests can lead to errors and omissions.
* Trained employees required: For conducting automated tests, trained employees with knowledge of programming languages and testing 
  knowledge are required.


Conclusion:
In conclusion, both manual testing and automated testing play crucial roles in ensuring software quality. While manual testing excels in
exploratory testing and usability testing, automated testing shines in regression, performance, and load testing. The choice between them
depends on factors such as project requirements, timeline, budget, and the nature of the application being tested.


PRINCIPLES OF SOFTWARE TESTING
------------------------------
Software testing is an important aspect of software development, ensuring that applications function correctly and meet user expectations.
From test planning to execution, analysis and understanding these principles help testers in creating a more structured and focused
approach to software testing, resulting in a higher-quality product.

Here are the Seven Principles of Software Testing:

1. Testing shows the Presence of Defects - 
The goal of software testing is to make the software fail. Software testing reduces the presence of defects. Software testing talks about
the presence of defects and doesn't talk about the absence of defects. Software testing can ensure that defects are present but it can
not prove that software is defect-free. Even multiple tests can never ensure that software is 100% bug-free. Testing can reduce the number
of defects but not remove all defects.

2. Exhaustive Testing is not Possible - 
It is the process of testing the functionality of the software in all possible inputs (valid or invalid) and pre-conditions is known as
exhaustive testing. Exhaustive testing is impossible means the software can never test at every test case. It can test only some test 
cases and assume that the software is correct and it will produce the correct output in every test case. If the software will test every
test case then it will take more cost, effort, etc., which is impractical.

3. Early Testing - 
To find the defect in the software, early test activity shall be started. The defect detected in the early phases of SDLC will be very 
less expensive. For better performance of software, software testing will start at the initial phase i.e. testing will perform at the 
requirement analysis phase.

4. Defect Clustering - 
In a project, a small number of modules can contain most of the defects. The Pareto Principle for software testing states that 80% of 
software defects come from 20% of modules.

5. Pesticide Paradox - 
Repeating the same test cases, again and again, will not find new bugs. So it is necessary to review the test cases and add or update
test cases to find new bugs.

6. Testing is Context-Dependent - 
The testing approach depends on the context of the software developed. Different types of software need to perform different types of 
testing. For example, The testing of the e-commerce site is different from the testing of the Android application.

7. Absence of Errors Fallacy - 
If a built software is 99% bug-free but does not follow the user requirement then it is unusable. It is not only necessary that software 
is 99% bug-free but it is also mandatory to fulfill all the customer requirements.

Conclusion
Software testing is essential for ensuring applications meet user expectations and function correctly. Understanding key principles like 
detecting defects early and recognizing the impossibility of exhaustive testing is vital for delivering reliable software.

Various types of testing, including unit, integration, regression, smoke, and system testing, offer unique benefits like early Bug 
Detection and Improved Code Quality. By embracing these principles and employing diverse testing methods, developers can enhance product 
quality and user satisfaction.

GOALS OF SOFTWARE TESTING
-------------------------
The main goal of Software Testing is to find bugs as early as possible, fix them, and deliver a fast, user-friendly product that meets 
both functional and non-functional requirements of the application while minimizing risks and costs.

Types of Goals in Software Testing - 

The goals of software testing may be classified into three major categories, which are as follows:

1. Immediate Goals - 
Immediate goals focus on the direct outcomes of testing. These objectives may be set at any time during the SDLC process which aims to 
catch the issues early and prevent the sources.

Some of these are covered in detail below:

1. Bug Discovery: This is the immediate goal of software testing to find errors at any stage of software development. The number of bugs 
   is discovered in the early stage of testing. The primary purpose of software testing is to detect flaws at any step of the development
   process. The higher the number of issues detected at an early stage, the higher the software testing success rate.
2. Bug Prevention: This is the immediate action of bug discovery, that occurs as a result of bug discovery. Everyone in the software 
   development team learns how to code from the behavior and analysis of issues detected, ensuring that bugs are not duplicated in 
   subsequent phases or future projects.

2. Long-Term Goals - 
These objectives have an impact on product quality in the long run after one cycle of the SDLC is completed. Long-term goals focus on 
improving product quality and user satisfaction over time, ensuring the software remains competitive and reliable after completing one
SDLC cycle.

Some of these are covered in detail below:

1. Quality: This goal enhances the quality of the software product. Because software is also a product, the user's priority is its quality.
   Superior quality is ensured by thorough testing. Correctness, integrity, efficiency, and reliability are all aspects that influence 
   quality. To attain quality, you must achieve all of the above-mentioned quality characteristics.
2. Customer Satisfaction: This goal verifies the customer's satisfaction with a developed software product. The primary purpose of 
   software testing, from the user's standpoint, is customer satisfaction. Testing should be extensive and thorough if we want the client
   and customer to be happy with the software product.
3. Reliability: It is a matter of confidence that the software will not fail. In short, reliability means gaining the confidence of the 
   customers by providing them with a quality product.
4. Risk Management: Risk is the probability of occurrence of uncertain events in the organization and the potential loss that could 
   result in negative consequences. Risk management must be done to reduce the failure of the product and to manage risk in different 
   situations.

3. Post-Implemented Goals
Post-implementation goals focus on the software’s performance after deployment and improving testing processes for future perspective.

Some of these are covered in detail below:

1. Reduce Maintenance Cost: Post-released errors are costlier to fix and difficult to identify. Because effective software does not wear 
   out, the maintenance cost of any software product is not the same as the physical cost. The failure of a software product due to 
   faults is the only expense of maintenance. Because they are difficult to discover, post-release mistakes always cost more to rectify.
   As a result, if testing is done thoroughly and effectively, the risk of failure is lowered, and maintenance costs are reduced as a 
   result.
2. Improved Software Testing Process: These goals improve the testing process for future use or software projects. These goals are known
   as post-implementation goals. A project's testing procedure may not be completely successful, and there may be room for improvement. 
   As a result, the bug history and post-implementation results can be evaluated to identify stumbling blocks in the current testing
   process that can be avoided in future projects.

Why Software Testing Needed?
Software checking out serves as a critical approach for confirming whether or not a software program product aligns with the expected 
requirements and ensuring it is free from defects.

The primary objective of software checking out is to point out mistakes, inconsistencies, or unmet necessities compared to the desired 
criteria. While software checking out does require a tremendous investment, it's vital to recognize that the consequences of software 
failure can be far more costly.

Conclusion
Software testing is more than just finding bugs, it is a strategic process that ensures quality, reliability, and user satisfaction while
minimizing risks and costs for the application. Testers play a important role, requiring not only technical expertise but also insight, 
communication, and a commitment to quality.

By addressing immediate, long-term, and post-implementation goals, testing delivers fast and reliable software that meets user needs.



