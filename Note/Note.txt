                                                            SOFTWARE TESTING
                                                        ------------------------

INTRODUCTION TO SOFTWARE TESTING
--------------------------------
Software Testing is a process of verifying and validating whether the Software Product or Application is working as expected or not. The
complete testing includes identifying errors and bugs that cause future problems for the performance of an application.

Software Testing Can be Divided into Two Steps:

1. Verification: This step involves checking if the software is doing what is supposed to do. Its like asking, "Are we building the 
   product the right way?"
2. Validation: This step verifies that the software meets the customer's needs and requirements. It's like asking, "Are we building the
   right product?"


What is Manual Testing?
Manual testing is a type of testing in which we do not use any tools or automation to perform the testing. In this testing, testers make
test cases for the codes test the software, and give the final report about that software. Manual testing is time-consuming testing 
because humans do it and there is a chance of human errors.

* Manual testing is conducted to discover bugs in the developed software application.
* The tester checks all the essential features of the application.
* The tester executes test cases and generates test reports without any help from the automation tools.
* It is conducted by the experienced tester to accomplish the testing process.

When to Perform Manual Testing?
Manual testing is done when automation can't be used or isn't enough. Here are key reasons and scenarios:

* Exploratory Testing: Discovering issues in new or unclear features by exploring them.
* Usability Testing: Checking if the UI is easy to use and looks good.
* Ad-Hoc Testing: Doing quick, informal tests after updates or bug fixes.
* Visual/GUI Testing: Checking the layout, colors, or how the site looks across different browsers.

Manual testing should be conducted when:

* Flexibility is required: With manual tests, QA can quickly test and provide fast feedback.
* Short-term projects: It is not advisable to invest more money and effort to set up short-term projects that focus on minor features
  because such setup will require huge effort and money that would be too high for such small projects.
* When testing end-user usability: Humans can use their sensibilities to understand the application behavior if the application offers a 
  satisfactory user journey. No machine can perform this task as humans can.

Benefits of Manual Testing -
Here are the Benefits of Manual Testing:

* Easy hiring: In manual testing, anyone can test so it helps in easy hiring.
* Fast feedback: Manual testing helps to provide fast and accurate feedback.
* Versatile: Manual test cases can be applied to many test cases.
* Flexible: Manual testing is flexible as it can adapt easily to changes in the user interface.
* Less expensive: Manual testing is less expensive as one does not need to spend a budget on automation tools and processes.

Limitations of Manual Testing - 
Here are the Limitations of Manual Testing:

* Not all defects detected: In manual cases, there is no assurance that there will be 100% test coverage as a result some of the defects
  may not be detected.
* High expertise: Although manual testing can be done by anyone, in some complex cases high expertise is required.
* Lots of time: Manual testing times extensive activity. It requires a lot of time to manually develop test cases so that all the 
  functionalities are covered and tested.
* Cannot be recorded: Manual testing process cannot be recorded so it is not possible to reuse the manual test cases.
* Less reliable: Manual testing is less reliable as it is conducted by humans and all test cases are designed by humans so there are 
  chances for human error.


What is Automation Testing?
Automation testing is a type of testing in which we take the help of tools (automation) to perform the testing. It is faster than manual 
testing because it is done with some automation tools. There is no chance of any human errors.

* It relies entirely on pre-scripted test which runs automatically to compare actual results with expected results.
* Automation testing helps the tester determine whether the application performs as expected or not.
* It allows the execution of repetitive tasks and regression tests.
* Automation requires manual effort to create initial testing scripts.

When to Perform Automation Testing?
* When need to run repetitive tasks: Automated tests are the best option in scenarios where there is a requirement to run repetitive tests.
  For example, in the case of regression tests must be executed periodically to make sure that the newly added code does not disrupt the 
  existing functionality of the software.
* When human resources are scarce: Automated tests are viable and the best option to get tests executed within deadlines when there are 
  only a limited number of dedicated testers.

Benefits of Automation Testing -
Here are Benefits of Automation Testing:

* Finds more bugs: Automation testing helps to find more bugs and defects in the software.
* Reduce time for regression tests: Automated tests are suitable for regression tests as the tests can be executed in a repetitive manner 
  periodically.
* The process can be recorded: This is one of the benefits of using automation tests as these tests can be recorded and thus allows to 
  reuse of the tests.
* No fatigue: As automation, tests are executed using software tools so there is no fatigue or tiring factor as in manual testing.
* Increased test coverage: Automation tests help to increase the test coverage as using the tool for testing helps to make sure that not
  even the smallest unit is left for testing.

Limitations of Automation Testing - 
Here are Limitations of Automation Testing:

* Difficult to inspect visual elements: In automated tests, it is difficult to get insight into the visual elements like color, font size,
  font type, button sizes, etc. as there is no human intervention.
* High cost: Automation tests have a high cost of implementation as tools are required for testing, thus adding the cost to the project 
  budget.
* Test maintenance is costly: In automation tests, test maintenance is costly.
* Not false proof: Automation tests also have some limitations and mistakes in automated tests can lead to errors and omissions.
* Trained employees required: For conducting automated tests, trained employees with knowledge of programming languages and testing 
  knowledge are required.


Conclusion:
In conclusion, both manual testing and automated testing play crucial roles in ensuring software quality. While manual testing excels in
exploratory testing and usability testing, automated testing shines in regression, performance, and load testing. The choice between them
depends on factors such as project requirements, timeline, budget, and the nature of the application being tested.


PRINCIPLES OF SOFTWARE TESTING
------------------------------
Software testing is an important aspect of software development, ensuring that applications function correctly and meet user expectations.
From test planning to execution, analysis and understanding these principles help testers in creating a more structured and focused
approach to software testing, resulting in a higher-quality product.

Here are the Seven Principles of Software Testing:

1. Testing shows the Presence of Defects - 
The goal of software testing is to make the software fail. Software testing reduces the presence of defects. Software testing talks about
the presence of defects and doesn't talk about the absence of defects. Software testing can ensure that defects are present but it can
not prove that software is defect-free. Even multiple tests can never ensure that software is 100% bug-free. Testing can reduce the number
of defects but not remove all defects.

2. Exhaustive Testing is not Possible - 
It is the process of testing the functionality of the software in all possible inputs (valid or invalid) and pre-conditions is known as
exhaustive testing. Exhaustive testing is impossible means the software can never test at every test case. It can test only some test 
cases and assume that the software is correct and it will produce the correct output in every test case. If the software will test every
test case then it will take more cost, effort, etc., which is impractical.

3. Early Testing - 
To find the defect in the software, early test activity shall be started. The defect detected in the early phases of SDLC will be very 
less expensive. For better performance of software, software testing will start at the initial phase i.e. testing will perform at the 
requirement analysis phase.

4. Defect Clustering - 
In a project, a small number of modules can contain most of the defects. The Pareto Principle for software testing states that 80% of 
software defects come from 20% of modules.

5. Pesticide Paradox - 
Repeating the same test cases, again and again, will not find new bugs. So it is necessary to review the test cases and add or update
test cases to find new bugs.

6. Testing is Context-Dependent - 
The testing approach depends on the context of the software developed. Different types of software need to perform different types of 
testing. For example, The testing of the e-commerce site is different from the testing of the Android application.

7. Absence of Errors Fallacy - 
If a built software is 99% bug-free but does not follow the user requirement then it is unusable. It is not only necessary that software 
is 99% bug-free but it is also mandatory to fulfill all the customer requirements.

Conclusion
Software testing is essential for ensuring applications meet user expectations and function correctly. Understanding key principles like 
detecting defects early and recognizing the impossibility of exhaustive testing is vital for delivering reliable software.

Various types of testing, including unit, integration, regression, smoke, and system testing, offer unique benefits like early Bug 
Detection and Improved Code Quality. By embracing these principles and employing diverse testing methods, developers can enhance product 
quality and user satisfaction.

GOALS OF SOFTWARE TESTING
-------------------------
The main goal of Software Testing is to find bugs as early as possible, fix them, and deliver a fast, user-friendly product that meets 
both functional and non-functional requirements of the application while minimizing risks and costs.

Types of Goals in Software Testing - 

The goals of software testing may be classified into three major categories, which are as follows:

1. Immediate Goals - 
Immediate goals focus on the direct outcomes of testing. These objectives may be set at any time during the SDLC process which aims to 
catch the issues early and prevent the sources.

Some of these are covered in detail below:

1. Bug Discovery: This is the immediate goal of software testing to find errors at any stage of software development. The number of bugs 
   is discovered in the early stage of testing. The primary purpose of software testing is to detect flaws at any step of the development
   process. The higher the number of issues detected at an early stage, the higher the software testing success rate.
2. Bug Prevention: This is the immediate action of bug discovery, that occurs as a result of bug discovery. Everyone in the software 
   development team learns how to code from the behavior and analysis of issues detected, ensuring that bugs are not duplicated in 
   subsequent phases or future projects.

2. Long-Term Goals - 
These objectives have an impact on product quality in the long run after one cycle of the SDLC is completed. Long-term goals focus on 
improving product quality and user satisfaction over time, ensuring the software remains competitive and reliable after completing one
SDLC cycle.

Some of these are covered in detail below:

1. Quality: This goal enhances the quality of the software product. Because software is also a product, the user's priority is its quality.
   Superior quality is ensured by thorough testing. Correctness, integrity, efficiency, and reliability are all aspects that influence 
   quality. To attain quality, you must achieve all of the above-mentioned quality characteristics.
2. Customer Satisfaction: This goal verifies the customer's satisfaction with a developed software product. The primary purpose of 
   software testing, from the user's standpoint, is customer satisfaction. Testing should be extensive and thorough if we want the client
   and customer to be happy with the software product.
3. Reliability: It is a matter of confidence that the software will not fail. In short, reliability means gaining the confidence of the 
   customers by providing them with a quality product.
4. Risk Management: Risk is the probability of occurrence of uncertain events in the organization and the potential loss that could 
   result in negative consequences. Risk management must be done to reduce the failure of the product and to manage risk in different 
   situations.

3. Post-Implemented Goals
Post-implementation goals focus on the software’s performance after deployment and improving testing processes for future perspective.

Some of these are covered in detail below:

1. Reduce Maintenance Cost: Post-released errors are costlier to fix and difficult to identify. Because effective software does not wear 
   out, the maintenance cost of any software product is not the same as the physical cost. The failure of a software product due to 
   faults is the only expense of maintenance. Because they are difficult to discover, post-release mistakes always cost more to rectify.
   As a result, if testing is done thoroughly and effectively, the risk of failure is lowered, and maintenance costs are reduced as a 
   result.
2. Improved Software Testing Process: These goals improve the testing process for future use or software projects. These goals are known
   as post-implementation goals. A project's testing procedure may not be completely successful, and there may be room for improvement. 
   As a result, the bug history and post-implementation results can be evaluated to identify stumbling blocks in the current testing
   process that can be avoided in future projects.

Why Software Testing Needed?
Software checking out serves as a critical approach for confirming whether or not a software program product aligns with the expected 
requirements and ensuring it is free from defects.

The primary objective of software checking out is to point out mistakes, inconsistencies, or unmet necessities compared to the desired 
criteria. While software checking out does require a tremendous investment, it's vital to recognize that the consequences of software 
failure can be far more costly.

Conclusion
Software testing is more than just finding bugs, it is a strategic process that ensures quality, reliability, and user satisfaction while
minimizing risks and costs for the application. Testers play a important role, requiring not only technical expertise but also insight, 
communication, and a commitment to quality.

By addressing immediate, long-term, and post-implementation goals, testing delivers fast and reliable software that meets user needs.


SOFTWARE DEVELOPMENT LIFE CYCLE (SDLC)
--------------------------------------

Software Development Life Cycle (SDLC) is a structured process that is used to design, develop, and test high-quality software. SDLC, or
software development life cycle, is a methodology that defines the entire procedure of software development step-by-step. The goal of the
SDLC life cycle model is to deliver high-quality, maintainable software that meets the user's requirements.

SDLC in software engineering models outlines the plan for each stage so that each stage of the software development model can perform its
task efficiently to deliver the software at a low cost within a given time frame that meets users requirements


What is the Software Development Life Cycle (SDLC)?
SDLC is a process followed for software building within a software organization. SDLC consists of a precise plan that describes how to
develop, maintain, replace, and enhance specific software. The life cycle defines a method for improving the quality of software and the
all-around development process.  

Stages of the Software Development Life Cycle
SDLC specifies the tasks to be performed at various stages by a software engineer or developer. It ensures that the end product is able 
to meet the customer's expectations and fits within the overall budget. Hence, it's vital for a software developer to have prior 
knowledge of this software development process.

The SDLC Model involves six phases or stages while developing any software.

Stage 1: Planning and Requirement Analysis - 
    Planning is a crucial step in everything, just as in software development. In this same stage, requirement analysis is also performed
by the developers of the organization. This is attained from customer inputs, and sales department/market surveys. 

The information from this analysis forms the building blocks of a basic project. The quality of the project is a result of planning. 
Thus, in this stage, the basic project is designed with all the available information.

                    
PLANNING ---> DEFINE PROJECT SCOPE ---> SET OBJECTIVES AND GOALS ---> RESOURCE PLANNING

Stage 2: Defining Requirements - 
    In this stage, all the requirements for the target software are specified. These requirements get approval from customers, market 
analysts and stakeholders. 
This is fulfilled by utilizing SRS (Software Requirement Specification). This is a sort of document that specifies all those things that
need to be defined and created during the entire project cycle. 

DEFINING ---> FUNCTIONAL REQUIREMENT ---> TECHNICAL REQUIREMENT ---> REQUIREMENT REVIEWS AND APPROVED

Stage 3: Designing Architecture - 
    SRS is a reference for software designers to come up with the best architecture for the software. Hence, with the requirements 
defined in SRS, multiple designs for the product architecture are present in the Design Document Specification (DDS). 

This DDS is assessed by market analysts and stakeholders. After evaluating all the possible factors, the most practical and logical
design is chosen for development.

DESIGN ---> LOW LEVEL DESIGN (LLD) ---> HIGH LEVEL DESIGN (HLD)

Stage 4: Developing Product - 
    At this stage, the fundamental development of the product starts. For this, developers use a specific programming code as per the 
design in the DDS. Hence, it is important for the coders to follow the protocols set by the association. Conventional programming tools
like compilers, interpreters, debuggers, etc. are also put into use at this stage. Some popular languages like C/C++, Python, Java, etc.
are put into use as per the software regulations. 

DEVELOPMENT ---> CODING STANDARD ---> SCALABLE CODE ---> VERSION CONTROL ---> CODE REVIEW


Stage 5: Product Testing and Integration - 
    After the development of the product, testing of the software is necessary to ensure its smooth execution. Although, minimal testing
is conducted at every stage of SDLC. Therefore, at this stage, all the probable flaws are tracked, fixed, and retested. This ensures that 
the product confronts the quality requirements of SRS. 

Documentation, Training, and Support: Software documentation is an essential part of the software development life cycle. A well-written
document acts as a tool and means to information repository necessary to know about software processes, functions, and maintenance. 
Documentation also provides information about how to use the product. Training in an attempt to improve the current or future employee 
performance by increasing an employee's ability to work through learning, usually by changing his attitude and developing his skills and
understanding. 

SYSTEM TESTING ---> MANUAL TESTING ---> AUTOMATED TESTING


Stage 6: Deployment and Maintenance of Products - 
    After detailed testing, the conclusive product is released in phases as per the organization’s strategy. Then it is tested in a real
industrial environment. It is important to ensure its smooth performance. If it performs well, the organization sends out the product as
a whole. After retrieving beneficial feedback, the company releases it as it is or with auxiliary improvements to make it further helpful
for the customers. However, this alone is not enough. Therefore, along with the deployment, the product's supervision. 

DEPLOYMENT AND MAINTENANCE ---> RELEASE PLANNING ---> DEPLOYMENT AUTOMATION ---> MAINTANENCE ---> FEEDBACK


What is the need for SDLC?
SDLC is a method, approach, or process that is followed by a software development organization while developing any software. SDLC models 
were introduced to follow a disciplined and systematic method while designing software. With the software development life cycle, the 
process of software design is divided into small parts, which makes the problem more understandable and easier to solve. SDLC comprises a
detailed description or step-by-step plan for designing, developing, testing, and maintaining the software.


Common SDLC Models -
1. Waterfall Model
2. Agile Model (Most Popular)
3. V-Model
4. Spiral Model
5. Incremental Model
6. RAD Model


How does SDLC Address Security?
A frequent issue in software development is the delay of security-related tasks until the testing phase, which occurs late in the software
development life cycle (SDLC) and occurs after the majority of crucial design and implementation has been finished. During the testing 
phase, security checks may be minimal and restricted to scanning and penetration testing, which may fail to identify more complicated
security flaws.

Security issue can be address in SDLC by following DevOps. Security is integrated throughout the whole SDLC, from build to production, 
through the use of DevSecOps. Everyone involved in the DevOps value chain have responsibility for security under DevSecOps.


Real Life Example of SDLC
Developing a banking application using SDLC:

1. Planning and Analysis: During this stage, business stakeholders' requirements about the functionality and features of banking 
   application will be gathered by program managers and business analysts. Detailed SRS (Software Requirement Specification) documentation
   will be produced by them. Together with business stakeholders, business analysts will analyze and approve the SRS document.
2. Design: Developers will receive SRS documentation. Developers will read over the documentation and comprehend the specifications. Web
   pages will be designed by designers. High level system architecture will be prepared by developers.
3. Development: During this stage, development will code. They will create the web pages and APIs needed to put the feature into practice.
4. Testing: Comprehensive functional testing will be carried out. They will guarantee that the banking platform is glitch-free and 
   operating properly.
5. Deployment and Maintenance: The code will be made available to customers and deployed. Following this deployment, the customer can 
   access the online banking. The same methodology will be used to create any additional features.


Conclusion
In conclusion, we now know that the Software Development Life Cycle (SDLC) in software engineering is an important framework for the better
and more structured development of optimized software programs. In a world full of rapid evolution in technology, SDLC phases plays a 
crucial role in enabling some good and innovative solutions for helping users and organizations. Also, it's better to adapt SDLC principles
to achieve software development goals effectively.



What is Software Modeling?
Software modeling is the process of creating abstract representations of a software system. These models serve as blueprints that guide
developers, designers, and stakeholders through the system’s structure, behavior, and functionality.

By using diagrams and various modeling languages, software modeling helps in visualizing and understanding the complex aspects of the 
software, making it easier to plan, develop, and manage the system.

Top 8 Software Development Models
Choosing the right model is very important for the Development of a Software Product or application. Development and testing processes are
carried out based on the model.

Different companies, depending on the software application or product, choose the type of development model whichever is appropriate for
their application. But these days 'Agile Methodology' is the most popular in the market.

Let's look at the every model in brief one by one:-

1. Agile Model - 
Agile Development Model is a combination of iterative and incremental models, that is, it is made up of iterative and incremental models.

In Agile model, focus is given to process adaptability and customer satisfaction.
In earlier times, iterative waterfall model was used to create software. But in today's time developers have to face many problems. The
biggest problem is that in the middle of software development, the customer asks to make changes in the software. It takes a lot of time
and money to make these changes. So to overcome all these shortcomings, the agile model was proposed in the 1990s.
The Agile Model was created mainly to make changes in the middle of software development so that the software project can be completed 
quickly.

* In the agile model, the software product is divided into small incremental parts. In this, the smallest part is developed first and 
  then the larger one. 
* And each incremental part is developed over iteration.
* Each iteration is kept small so that it can be easily managed. And it can be completed in two-three weeks. Only one iteration is planned,
  developed and deployed at a time.

Phases of Agile Model:

REQUIREMENTS ---> DESIGN ---> DEVELOP ---> TEST ---> DEPLOY ---> REVIEW 

2. Waterfall Model - 
    Waterfall Model is a famous and good version of SDLC(System Development Life Cycle) for software engineering. The waterfall model is a
linear and sequential model, which means that a development phase cannot begin until the previous phase is completed. We cannot overlap 
phases in waterfall model.

Phases of Waterfall model: 

REQUIREMENTS ---> DESIGN ---> IMPLEMENTATION ---> VERIFICATION ---> MAINTAINANCE

Similarly waterfall model also works, once one phase of development is completed then we move to the next phase but cannot go back to the
previous phase. In the waterfall model, the output of one phase serves as the input for the other phase.

3. V-Model - 
    V-Model is an SDLC model, it is also called Verification and Validation Model. V-Model is widely used in the Software Development
Process, and it is considered a disciplined model. In V-Model, the execution of each process is sequential, that is, the new phase starts
only after the previous phase ends.

* It is based on the association of testing phase with each development phase that is in V-Model with each development phase, its testing 
  phase is also associated in a V-shape in other words both Software Development and testing activities take place at the same time.
* So in this model, Verification Phase will be on one side, Validation Phase will be on the other side that is both the activities run 
  simultaneously and both of them are connected to each other in V-Shape through Coding Phase, hence it is called V-Model.
* V-Design: In V-Design the left side represents the development activity, the right side represents the testing activity.

4. Incremental Model
    In Incremental Model, the Software Development Process is divided into several increments and the same phases are followed in each 
increment. In simple language, under this model a complex project is developed in many modules or builds.

* For example, we collect the customer's requirements, now instead of making the entire software at once, we first take some requirements 
  and based on them create a module or function of the software and deliver it to the customer. Then we take some more requirements and
  based on them add another module to that software.
* Similarly, modules are added to the software in each increment until the complete system is created. However, the requirements for making
  a complex project in multiple iterations/parts should be clear.
* If we understand the entire principle of Incremental methodology, then it starts by developing an initial implementation, then user
  feedback is taken on it, and it is developed through several versions until an accepted system is developed. Important functionalities
  of the software are developed in the initial iterations.

Each subsequent release of a software module adds functions to the previous release. This process continues until the final software is
obtained.

5. RAD Model - 
    RAD Model stands for rapid application development model. The methodology of RAD model is similar to that of incremental or waterfall
model. It is used for small projects.

The main objective of RAD model is to reuse code, components, tools, processes in project development.

* If the project is large then it is divided into many small projects and these small projects are planned one by one and completed. In
  this way, by completing small projects, the large project gets ready quickly.
* In RAD model, the project is completed within the given time and all the requirements are collected before starting the project. It is
  very fast and there are very less errors in it.

6. Iterative Model - 
    In Iterative Model we start developing the software with some requirements and when it is developed, it is reviewed. If there are 
requirements for changes in it, then we develop a new version of the software based on those requirements. This process repeats itself 
many times until we get our final product.

Through this diagram you can understand the Interactive model.

* So, in Iterative model a software is developed by following several iterations. Iteration means that we are repeating the Development 
  Process again and again. For example, we develop the first version of the software following the SDLC process with some software 
  requirements.
* After the first version is developed, if there is a need to change the software , then a new version is developed with the second 
  iteration. Now again we will see if the new version is enough, if not then we will make changes in it with the third iteration. The 
  iteration will be repeated until the complete software is ready.
* The basic concept of Iterative model is that the software should be developed through repeated cycles or what we also call iteration 
  and only a small part of it should be developed at a time. This model was developed to overcome the drawbacks of the classical 
  waterfall model.

7. Spiral Model - 
    Spiral Model is a software development process model. This model has characteristics of both iterative and waterfall models. This 
model is used in projects which are large and complex. This model was named spiral because if we look at its figure, it looks like a 
spiral, in which a long curved line starts from the center point and makes many loops around it. The number of loops in the spiral is not
decided in advance but it depends on the size of the project and the changing requirements of the user. We also call each loop of the 
spiral a phase of the software development process.

In Spiral Model the entire process of software development is described in four phases which are repeated until the project is completed.

A software project goes through these loops again and again in iterations. After each iteration a more and more complete version of the
software is developed. The most special thing about this model is that risks are identified in each phase and they are resolved through
prototyping. This feature is also called Risk Handling.

Since it also includes the approaches of other SDLC models, it is also called Meta Model. It was first developed by Barry Boehm in 1986.


8. Prototype model - 
    Prototype Model is an activity in which prototypes of software applications are created. First a prototype is created and then the 
final product is manufactured based on that prototype.

One problem in this model is that if the end users are not satisfied with the prototype model, then a new prototype model is created 
again, due to which this model consumes a lot of money and time.

* The prototype model was developed to overcome the shortcomings of the waterfall model.
* This model is created when we do not know the requirements well.
* The specialty of this model is that this model can be used with other models as well as alone.


Why companies are shifting toward agile Software Development models?
In earlier times, iterative waterfall model was used to create software. But in today's time developers have to face many problems. The
biggest problem is that in the middle of software development, the customer asks to make changes in the software. It takes a lot of time
and money to make these changes. The agile model was created mainly to make changes in the middle of Software Development so that the 
software project can be completed quickly.

Agile focuses on customer-centric approach that constantly take feedback from customer and make changes in the middle of software developer
according to their needs and expectation. Agile Methodologies like scrum adopt iterative and incremental approach this accelerate the 
time-to-market for new features and product.

Conclusion
Choosing the right software development model is important for the Success of a Project. Each model offers unique advantages and is
suitable for Different Types of Projects. Agile Methodologies, due to their flexibility and customer-centric approach, are increasingly
popular in the industry. By adopting Agile, companies can accelerate time-to-market and better adapt to changing requirements, leading to
higher customer satisfaction and Successful Project Outcomes.



SOFTWARE TESTING LIFE CYCLE (STLC)
----------------------------------

The Software Testing Life Cycle (STLC) is a process that verifies whether the Software Quality meets the expectations or not. STLC is an
important process that provides a simple approach to testing through the step-by-step process, which we are discussing here. Software 
Testing Life Cycle (STLC) is a fundamental part of the Software Development Life Cycle (SDLC).

Phases of STLC - 
There are six major phases of the Software Testing Life Cycle (STLC):

REQUIREMENT ANALYSIS ---> TEST PLANNING ---> TEST CASE DEVELOPMENT ---> TEST ENVIRONMENT SETUP ---> TEST EXECUTION ---> TEST ENCLOSURE

1. Requirement Analysis - 
    Requirement Analysis is the first phase where the QA/testing team understands what needs to be tested. The activities that take place 
during the Requirement Analysis stage include:

* Reviewing the software requirements document (SRD) and other related documents
* Interviewing stakeholders to gather additional information
* Identifying any ambiguities or inconsistencies in the requirements
* Identifying any missing or incomplete requirements
* Identifying any potential risks or issues that may impact the testing process

2. Test Planning - 
    Test Planning is the most crucial phase where the overall test strategy and plan are created. The major activities carried out during
the Test Planning phase include:

* Identifying the testing objectives and scope
* Developing a test strategy: selecting the testing methods and techniques that will be used
* Identifying the testing environment and resources needed
* Identifying the test cases that will be executed and the test data that will be used
* Estimating the time and cost required for testing
* Identifying the test deliverables and milestones
* Assigning roles and responsibilities to the testing team
* Reviewing and approving the test plan

3. Test Case Development - 
    The Test Case Development phase testers design detailed test cases and prepare the necessary test data. The main activities performed 
during the Test Case Development phase include:

* Identifying the test cases that will be developed
* Writing test cases that are clear, concise and easy to understand
* Creating test data and test scenarios that will be used in the test cases
* Identifying the expected results for each test case
* Reviewing and validating the test cases
* Updating the requirement traceability matrix (RTM) to map requirements to test cases

4. Test Environment Setup - 
    Test Environment Setup defines the hardware, software and network conditions under which testing will be executed. The activities 
involved in the Test Environment Setup phase include:

* Install and configure required software, tools and databases.
* Set up servers, browsers, operating systems and devices.
* Prepare access credentials and permissions.
* Validate the environment before test execution.

5. Test Execution -
    In Test Execution phase prepared test cases are executed in the defined environment. The activities performed during the Test
Execution phase include:

* Run manual or automated test cases.
* Log defects with details like severity and priority.
* Retest fixed defects (defect retesting).
* Perform regression testing if required.
* Collect and analyze test results.
* Document and share test reports.

6. Test Closure - 
    Test Closure is the final phase where testing activities are completed and documented. The final activities carried out during the 
Test Closure phase include:

* Prepare a Test Summary Report (test cases executed, pass/fail count, defects found/resolved).
* Ensure all defects are tracked and closed.
* Clean up the test environment.
* Archive test cases, data and reports.
* Conduct a retrospective for lessons learned.
* Share knowledge with stakeholders.

